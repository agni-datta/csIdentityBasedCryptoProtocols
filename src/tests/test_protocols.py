from hashlib import sha3_256
from typing import Tuple

from charm.toolbox.pairinggroup import G1, ZR, Element, PairingGroup, pair

# Initialize pairing group with an elliptic curve that supports bilinear pairings.
GROUP = PairingGroup("MNT224")


def generate_keys() -> Tuple[Element, Element, Element]:
    """
    Generates a generator, public key, and private key.

    Returns:
        Tuple containing the generator, private key, and public key.
    """
    generator = GROUP.random(G1)
    private_key = GROUP.random(ZR)
    public_key = generator**private_key
    return generator, private_key, public_key


def create_proof(
    generator: Element, public_key: Element, private_key: Element, user_input: str
) -> Tuple[Element, Element]:
    """
    Creates a proof of knowledge of the private key.

    Args:
        generator: The generator element.
        public_key: The public key element.
        private_key: The private key element.
        user_input: The user input as a string.

    Returns:
        Tuple containing y_value and z_value, the components of the proof.
    """
    random_value = GROUP.random(ZR)
    y_value = generator**random_value
    hash_input = sha3_256((user_input + str(y_value)).encode()).digest()
    challenge = GROUP.init(ZR, int.from_bytes(hash_input, byteorder="big"))
    z_value = random_value - (private_key * challenge)
    return y_value, z_value


def verify_proof(
    generator: Element,
    public_key: Element,
    user_input: str,
    proof: Tuple[Element, Element],
) -> bool:
    """
    Verifies the proof generated by the prover.

    Args:
        generator: The generator element.
        public_key: The public key element.
        user_input: The user input as a string.
        proof: Tuple containing y_value and z_value, the components of the proof.

    Returns:
        Boolean indicating whether the proof is valid.
    """
    y_value, z_value = proof
    hash_input = sha3_256((user_input + str(y_value)).encode()).digest()
    challenge = GROUP.init(ZR, int.from_bytes(hash_input, byteorder="big"))
    lhs = pair(generator, y_value)
    rhs = (
        pair(generator, generator) ** z_value * pair(public_key, generator) ** challenge
    )
    return lhs == rhs


def main() -> None:
    """
    Main function to demonstrate the Schnorr-like identification scheme using bilinear pairings.
    """
    generator, private_key, public_key = generate_keys()
    password = "secure_password"

    proof = create_proof(generator, public_key, private_key, password)
    verification_result = verify_proof(generator, public_key, password, proof)

    print("Public key (generator, public_key):", (generator, public_key))
    print("Proof (y_value, z_value):", proof)
    print("Verification Result:", verification_result)


if __name__ == "__main__":
    main()
